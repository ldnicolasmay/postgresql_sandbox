---
title: "PostgreSQL Tutorial - Home - Section 11"
output: 
  html_notebook:
    theme: sandstone
    highlight: zenburn
    toc: true
    toc_float: true
---

Load libraries.
```{r}
library(DBI)
library(odbc)
library(RPostgres)
library(dplyr)
```


# Managing Tables

## Data Types

### Boolean

Keyword(s): `BOOLEAN` or `BOOL`

| Values  | Notes |
|---------|------------------------------------------------|
| `FALSE` | `0`, `'no'`, `'n'`, `'f'`, `'false'` all equal `FALSE` |
| `TRUE`  | `1`, `'yes'`, `'y'`, `'t'`, `'true'` all equal `TRUE`  |
| `NULL`  |       |


### Character

There are three types of character fields: `CHAR`, `VARCHAR`, and `TEXT`.

| Data Type | Keyword(s) | Notes | 
|-----------|--------------|----------------------------------------|
| Character | `CHAR(n)`  | `n` is how many characters per entry; fixed-length character values with space padding to fill in `n` |
| Varying Character | `VARCHAR(n)` | variable length; `n` is max number of characters per entry; unlike, `CHAR` the entries are not padded with spaces |
| Text      | `TEXT`     | variable length; theoretically unlimited length |


### Numeric

PostgreSQL provides 2 types of numbers:

1. Integers
2. Floating-Point Numbers

#### Integer

PostgreSQL provies 4 main types of integers: `SMALLINT`, `INTEGER`, `BIGINT` and `SERIAL`.

There are many different types of integers. Read the documentation (Chapter 8, Data Types) for the full list.

| Data Type | Keyword(s) | Notes |
|-----------|------------|----------------------------------------|
| Small Integer | `SMALLINT` or `INT2` | 2-byte signed integer:<br /> -32,768 to 32,767 |
| Integer       | `INTEGER` or `INT`   | 4-byte signed integer:<br /> -2,147,483,648 to 2,147,483,647 |
| Big Integer   | `BIGINT` or `INT8`   | 8-byte signed integer:<br />  -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 |
| Serial        | `SERIAL`             | autoincrementing 4-byte integer |

#### Floating-Point Number

There are 2 main types of floating-point numbers: `NUMERIC`, `REAL`/`DOUBLE PRECISION`, and `FLOAT`.

| Data Type | Keyword(s) | Notes |
|-----------|------------|-----------------------------------------|
| Exact Arbitrary Precision Number  | `NUMERIC(p, s)` | `p` is precision, `s` is scale; precision is total count of signif. digits in the number as a whole, scale is count of digits after the decimal point; 23.5141 is a `NUMERIC(6, 4)`; recommended for storing monetary amounts and other quantities where exactness is required |
| Inexact Variable Precision Number | `REAL` | typically, has a range of at least 1E-37 to 1E+37 with a precision of at least 6 decimal digits |
| Inexact Variable Precision Number | `DOUBLE PRECISION` | typically has a range of around 1E-307 to 1E+308 with a precision of at least 15 digits |
| SQL standard `FLOAT` | `FLOAT(n)` | `FLOAT(1)` to `FLOAT(24)` is just `REAL`; `FLOAT(25)` to `FLOAT(53)` is just `DOUBLE PRECISION` |

### Temporal Data Types

PostgreSQL has 5 main temporal data types: `DATE`, `TIME`, `TIMESTAMP`, `TIMESTAMPTZ`, and `INTERVAL`.

| Data Type | Keyword(s) | Notes |
|-----------|------------|-------------------------------------------|
| Date | `DATE` | calendar date (year, month, day) |
| Time | `TIME` | time of day (no time zone), HH:MM:SS from `00:00:00` to `24:00:00` |
| Time w/ timezone | `TIMETZ` | time of day (w/ time zone), HH:MM:SS from `00:00:00` to `24:00:00` |
| Datetime | `TIMESTAMP` | e.g., `2016-06-22 19:10:25` |
| Datetime w/ timezone | `TIMESTAMPTZ` | e.g., `2016-06-22 19:10:25-07` |
| Interval | `INTERVAL` | There's quite a bit to this... read documentation section 8.5.4. Interval Input for more info |


### Arrays

In PostgreSQL, you can store an array of strings, an array of integers, etc., in array columns. The array comes in handy in some situations e.g., storing days of the week, months of the year.


### JSON

PostgreSQL provides two JSON data types: `JSON` and `JSONB` for storing JSON data.

The `JSON` data type stores plain JSON data that requires reparsing for each processing, while `JSONB` data type stores JSON data in a binary format which is faster to process but slower to insert. In addition, `JSONB` supports indexing, which can be an advantage.


### UUID

The `UUID` data type allows you to store Universal Unique Identifiers defined by RFC 4122 . The `UUID` values guarantee a better uniqueness than `SERIAL` and can be used to hide sensitive data exposed to the public such as values of `id` in URL.


### Special Data Types

Besides the primitive data types, PostgreSQL also provides several special data types related to geometric and network.

* `box` - a rectangular box
* `line` - a set of points
* `point` - a geometric pair of numbers
* `lseg` - a line segment
* `polygon` - a closed geometric
* `inet` - an IP4 address
* `macaddr` -  a MAC address


## CREATE TABLE

Here's the general `CREATE TABLE` syntax.

```
CREATE TABLE table_name (
  column_name  TYPE  column_constraint,
  column_name  TYPE  column_constraint,
  ...
  table_constraint  table_constraint ...
) INHERITS existing_table_name;
```

### Column constraints

Here are some commonly used column constraints.

* `NOT NULL` - A record's value in such a column cannot be `NULL`.
* `UNIQUE` - A record's value in such a column must be unique _across the whole table_. However, the column can have many `NULL` values because PostgreSQL considers each `NULL` value unique.
* `PRIMARY KEY` - This is a combination of `NOT NULL` and `UNIQUE`. This can be used as a column constraint if only one column is the primary key. If multiple columns are the primary key, you'll have to define those primary keys as table constraints.
* `CHECK (condition)` - Enables a `CHECK` condition when you insert or update data.
* `REFERENCES` - Constrains a record's value in such a column to a corresponding value in another table's column. It's used to define the foreign key constraint.

### Table constraints

Here are some common table constraints.

* `UNIQUE (column_name, column_name, ...)` - Force value stored in the columns listed to be unique.
* `PRIMARY KEY (column_name, column_name, ...)` - Define a primary key consisting of multiple columns.
* `CHECK (condition)` - Like column constraing `CHECK`.
* `REFERENCES` - Like column constraint `REFERENCES`.

### CREATE TABEL example

We'll create tables named "account", "role", and "account_roles".

Connect to the _**example**_ database.

```{r}
con_ex <- dbConnect(odbc::odbc(), "PostgreSQL AWS example")
```

```{sql connection=con_ex}
DROP TABLE IF EXISTS account_role;
DROP TABLE IF EXISTS account;
DROP TABLE IF EXISTS role;
```

Create the "account" table.

```{sql connection=con_ex}
CREATE TABLE IF NOT EXISTS account (
  user_id     SERIAL        PRIMARY KEY,
  username    VARCHAR(50)   UNIQUE NOT NULL,
  password    VARCHAR(50)   NOT NULL,
  email       VARCHAR(355)  UNIQUE NOT NULL,
  created_on  TIMESTAMP     NOT NULL DEFAULT CURRENT_TIMESTAMP,
  last_login  TIMESTAMP
);
```

Create the "role" table.

```{sql connection=con_ex}
CREATE TABLE IF NOT EXISTS role (
  role_id    SERIAL        PRIMARY KEY,
  role_name  VARCHAR(255)  UNIQUE NOT NULL
)
```

Create the "account_role" table.

```{sql connection=con_ex}
CREATE TABLE IF NOT EXISTS account_role (
  user_id     INTEGER    NOT NULL,
  role_id     INTEGER    NOT NULL,
  grant_date  TIMESTAMP  WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (user_id, role_id),            -- table constraint #1
  CONSTRAINT account_role_role_id_fkey FOREIGN KEY (role_id)
    REFERENCES role (role_id) MATCH SIMPLE
    ON UPDATE NO ACTION ON DELETE NO ACTION, -- table constraint #2
  CONSTRAINT account_role_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES account (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION ON DELETE NO ACTION  -- table constraint #3
);
```

The `PRIMARY KEY` table constraint makes sense.

The 2nd and 3rd constraints except `MATCH SIMPLE`. I'm guessing what this means, but I'll have to wait until there's more info on table constraints language. Looking forward to that!

Before I move on, I'd like to add some data to these tables to make sure I understand how these work. The "account_role" looks like a junction table to make a many-to-many relationship possible between accounts and roles.

```{sql connection=con_ex}
INSERT INTO 
  account(username, password, email)
VALUES
  ('bill100', 'samwise', 'bill100@gmail.com'), -- admin, power_user
  ('jenny', 'gamgee', 'jenny@gmail.com'),      -- admin, user
  ('luke1234', 'frodo', 'tolkienisawesome@gmail.com'), -- user
  ('samantha2000', 'baggins', 'billy.the.kid@hotmail.com'); -- power_user
```

```{sql connection=con_ex}
SELECT * FROM account;
```

```{sql connection=con_ex}
INSERT INTO
  role(role_name)
VALUES
  ('user'),
  ('power_user'),
  ('admin');
```

```{sql connection=con_ex}
SELECT * FROM role;
```

```{sql connection=con_ex}
INSERT INTO
  account_role(user_id, role_id)
VALUES
  (1, 1),
  (1, 3),
  (2, 2),
  (2, 3),
  (3, 1),
  (4, 2);
```

```{sql connection=con_ex}
SELECT * FROM account_role;
```

What roles does the user "bill100" have?

This requires a double join across the junction table "account_role".

```{sql connection=con_ex}
SELECT
  account_role.user_id,
  account_role.role_id,
  -- role.role_id,
  role.role_name
FROM
  account_role
INNER JOIN
  role
  ON account_role.role_id = role.role_id;
```

```{sql connection=con_ex}
SELECT
  account.user_id,
  account.username,
  account_role_role.role_id,
  account_role_role.role_name
FROM
  account
INNER JOIN
  (
    SELECT
      account_role.user_id,
      account_role.role_id,
      role.role_name
    FROM
      account_role
    INNER JOIN
      role
    ON account_role.role_id = role.role_id
  ) AS account_role_role
  ON account.user_id = account_role_role.user_id
  WHERE account.username = 'bill100';
```

```{r}
dbGetQuery(con_ex,
"
SELECT
  -- account.user_id,
  -- account.username,
  -- account_role_role.role_id,
  account_role_role.role_name
FROM
  account
INNER JOIN
  (
    SELECT
      account_role.user_id,
      account_role.role_id,
      role.role_name
    FROM
      account_role
    INNER JOIN
      role
    ON account_role.role_id = role.role_id
  ) AS account_role_role
  ON account.user_id = account_role_role.user_id
  WHERE account.username = 'bill100';
") %>% 
  dplyr::pull()
```

Disconnect from the _**example**_ database.

```{r}
dbDisconnect(con_ex)
```


## SELECT INTO

`SELECT INTO` allows you to create a new table and insert the data from a query. `SELECT INTO` doesn't return data to the client.

Here's the syntax.

```
SELECT
  col_1, col_2, ...
INTO [TEMPORARY] [TABLE]
  new_table
FROM
  existing_table
WHERE
  [condition];
```

You can also do joins.

```
SELECT
  existing_table_1.col_1, 
  existing_table_1.col_2,
  ...,
  existing_table_2.col_1,
  existing_table_2.col_2,
  ...
INTO [TEMPORARY] [TABLE]
  new_table
FROM
  existing_table_1
INNER JOIN
  existing_table_2
  ON existing_table_1.col_1 = existing_table_2.col_1;
```

Note that you cannot use the `SELECT INTO` statement in PL/pgSQL or ECPG because they interpret the `INTO`clause differently. Use the `CREATE TABLE AS` statement instead... it provides more functionality.

We'll use the "film" table in the _**dvdrental**_ database.

```{r}
con_dvd <- dbConnect(odbc::odbc(), "PostgreSQL AWS dvdrental")
```

Let's create a temporary table of all the films whose ratings are 'R' and the rental period is 5 days.

```{sql connection=con_dvd}
DROP TABLE IF EXISTS film_r;
```


```{sql connection=con_dvd}
SELECT
  film_id,
  title,
  rating
INTO TEMPORARY TABLE
  film_r
FROM
  film
WHERE
  rating = 'R' AND rental_duration = 5
ORDER BY
  title;
```

The temporary table created above doesn't show up in the list of tables returned by `DBI::dbListTables`.

```{r}
dbListTables(con_dvd)
```

But it is there now.

```{sql connection=con_dvd}
SELECT * FROM film_r;
```

>
> What happens when I disconnect and reconnect?
> 
```{r}
# dbDisconnect(con_dvd)
# con_dvd <- dbConnect(odbc::odbc(), "PostgreSQL AWS dvdrental")
```

```{sql connection=con_dvd}
-- SELECT * FROM film_r;
```
> 
> It disappears!
> 

How about a temporary table of short films (i.e., `length` < 60 minutes)?

```{sql connection=con_dvd}
DROP TABLE IF EXISTS short_film;
```


```{sql connection=con_dvd}
SELECT
  film_id,
  title,
  length
INTO TEMPORARY TABLE
  short_film
FROM
  film
WHERE
  length < 60
ORDER BY
  length DESC,
  title;
```

```{sql connection=con_dvd}
SELECT * FROM short_film;
```

Cool.

Disconnect from the _**dvdrental**_ database.

```{r}
dbDisconnect(con_dvd)
```


```{r echo=FALSE}
###@    #==--  :  --==#    @##==---==##@##==---==##@    #==--  :  --==#    @###
#==##@    #==-- --==#    @##==---==##@   @##==---==##@    #==-- --==#    @##==#
#--==##@    #==-==#    @##==---==##@   #   @##==---==##@    #==-==#    @##==--#
#=---==##@    #=#    @##==---==##@    #=#    @##==---==##@    #=#    @##==---=#
##==---==##@   #   @##==---==##@    #==-==#    @##==---==##@   #   @##==---==##
#@##==---==##@   @##==---==##@    #==-- --==#    @##==---==##@   @##==---==##@#
#  @##==---==##@##==---==##@    EXTRA  :  SPACE    @##==---==##@##==---==##@  #
#@##==---==##@   @##==---==##@    #==-- --==#    @##==---==##@   @##==---==##@#
##==---==##@   #   @##==---==##@    #==-==#    @##==---==##@   #   @##==---==##
#=---==##@    #=#    @##==---==##@    #=#    @##==---==##@    #=#    @##==---=#
#--==##@    #==-==#    @##==---==##@   #   @##==---==##@    #==-==#    @##==--#
#==##@    #==-- --==#    @##==---==##@   @##==---==##@    #==-- --==#    @##==#
###@    #==--  :  --==#    @##==---==##@##==---==##@    #==--  :  --==#    @###
#==##@    #==-- --==#    @##==---==##@   @##==---==##@    #==-- --==#    @##==#
#--==##@    #==-==#    @##==---==##@   #   @##==---==##@    #==-==#    @##==--#
#=---==##@    #=#    @##==---==##@    #=#    @##==---==##@    #=#    @##==---=#
##==---==##@   #   @##==---==##@    #==-==#    @##==---==##@   #   @##==---==##
#@##==---==##@   @##==---==##@    #==-- --==#    @##==---==##@   @##==---==##@#
#  @##==---==##@##==---==##@    EXTRA  :  SPACE    @##==---==##@##==---==##@  #
#@##==---==##@   @##==---==##@    #==-- --==#    @##==---==##@   @##==---==##@#
##==---==##@   #   @##==---==##@    #==-==#    @##==---==##@   #   @##==---==##
#=---==##@    #=#    @##==---==##@    #=#    @##==---==##@    #=#    @##==---=#
#--==##@    #==-==#    @##==---==##@   #   @##==---==##@    #==-==#    @##==--#
#==##@    #==-- --==#    @##==---==##@   @##==---==##@    #==-- --==#    @##==#
###@    #==--  :  --==#    @##==---==##@##==---==##@    #==--  :  --==#    @###
```
