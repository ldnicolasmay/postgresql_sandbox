---
title: "PostgreSQL Tutorial - Home - Section 7"
output: 
  html_notebook:
    theme: cerulean
    highlight: espresso
---

Load libraries.
```{r}
library(DBI)
library(odbc)
library(RPostgres)
```


# Subquery

## Subquery (Inner Query)

Suppose we want to find the films whose rental rate is higher than the average rental rate. We can do this in two steps:

1. Find the average rental rate by using the `SELECT` statement and `AVG` function.
2. Use the result of the first query in the second `SELECT` statement to find the films we want.

Connect to the _**dvdrental**_ database.

```{r}
con_dvd <- dbConnect(odbc::odbc(), "PostgreSQL AWS dvdrental")
```

1. Get the average rental rate.
```{sql connection=con_dvd}
SELECT
  AVG(rental_rate)
FROM
  film;
```

The average rental rate is $2.98.

No we can get the films whose rental rate is higher than the average rental rage.

```{sql connection=con_dvd}
SELECT
  film_id,
  title,
  rental_rate
FROM
  film
WHERE
  rental_rate > 2.98;
```

This 2-step solution isn't elegant. We can solve this problem with one query using a subquery (a.k.a., inner query).

A subquery is a query nested inside another query such as `SELECT`, `INSERT`, `DELETE`, and `UPDATE`. Here we'll only focus on the `SELECT statement.

### Subquery example

Here's how we'd construct a subquery within a query to solve the above problem in 1 step.

```{sql connection=con_dvd}
SELECT
  film_id,
  title,
  rental_rate
FROM
  film
WHERE
  rental_rate > (
    SELECT
      AVG(rental_rate)
    FROM
      film
    );
```

### Subquery with `IN` operator example

Say we want to get the titles for all the films that were returned between May 29, 2005 and May 30, 2005.

We have to use the "rental" and join the "inventory" table.

```{sql connection=con_dvd}
SELECT * FROM rental LIMIT 5;
```

```{sql connection=con_dvd}
SELECT * FROM inventory LIMIT 5;
```

```{sql connection=con_dvd}
SELECT
  inventory.film_id
FROM
  rental
INNER JOIN 
  inventory
  ON rental.inventory_id = inventory.inventory_id
WHERE
  return_date BETWEEN '2005-05-29' AND '2005-05-30'
ORDER BY film_id;
```

```{sql connection=con_dvd}
SELECT * FROM film LIMIT 5;
```

```{sql connection=con_dvd}
SELECT
  film.film_id,
  film.title
FROM
  film
WHERE
  film_id IN (
    SELECT
      inventory.film_id
    FROM
      rental
    INNER JOIN 
      inventory
      ON rental.inventory_id = inventory.inventory_id
    WHERE
      return_date BETWEEN '2005-05-29' AND '2005-05-30'
    ORDER BY
      film_id
  );
```

### Subquery with `EXISTS` operator example

A subquery can be an input of the `EXISTS` operator. If the subquery returns any row, the `EXISTS` operator returns true. If the subquery returns no row, the result of the `EXISTS` operator is false.

The `EXISTS` operator only caures about the number of rows returned from the subquery (0 or 1+), not about the content of the rows. So, the common coding convention of `EXISTS` is as follows.

```
EXISTS (SELECT 1 FROM table WHERE [condition]);
```

Here's an example.

This `INNER JOIN` returns all the `first_name`, `last_name` rows where there's a `customer_id` in both the "payment" and "customer" tables.

```{sql connection=con_dvd}
SELECT
  first_name,
  last_name
FROM
  payment
INNER JOIN
  customer
  ON payment.customer_id = customer.customer_id
ORDER BY
  first_name,
  last_name;
```

But notice we have repeated rows.

The repeated rows can be eliminated by using a subquery with the `EXISTS` operator.

```{sql connection=con_dvd}
SELECT
  first_name,
  last_name
FROM
  customer
WHERE
  EXISTS (
    SELECT
      1
    FROM
      payment
    WHERE
      payment.customer_id = customer.customer_id
  )
ORDER BY
  first_name,
  last_name;
```

_Note: This last thing (subquery with `EXISTS`) isn't super clear what's going on here. May need to revisit._

Disconnect from the _**dvdrental**_ database.

```{r}
if (exists("con_dvd")) { dbDisconnect(con_dvd); rm(con_dvd); }
```


## ANY Operator

The PostgreSQL `ANY` operator compares a value to a set of values returned by a subquery. The following illustrates the the syntax of the `ANY` operator.

```
SELECT
  col_1
FROM
  table_1
WHERE
  col_2 >= ANY(
    [subquery]
  );
```

Here are the rules for an `ANY` query:

1. The subquery must return exactly one columns.
2. The `ANY` operator must be preceded by by one of the following comparison operators: `=`, `<>`/`!=`, `<`, `>`, `<=`, `>=`.
3. The `ANY` operator returns true if any value of the subquery meets the condition... otherwise it returns false.

Note that `SOME` is a synonym for `ANY`. They're the same.

### `ANY` operator examples

We'll use the "film" and "film_category" tables from the _**dvdrental**_ database.

Connect to the database.
```{r}
con_dvd <- dbConnect(odbc::odbc(), "PostgreSQL AWS dvdrental")
```

```{r}
dbListFields(con_dvd, "film")
```

```{r}
dbListFields(con_dvd, "film_category")
```

The following example returns the maximum length of film grouped by category.

```{sql connection=con_dvd}
SELECT
  film_category.category_id,
  MAX(film.length)
FROM
  film
INNER JOIN
  film_category
  ON film.film_id = film_category.film_id
GROUP BY
  film_category.category_id
ORDER BY
  film_category.category_id;
```

To use `ANY`, we need to return exactly one columns... the "max" column.

```{sql connection=con_dvd}
SELECT
  MAX(film.length)
FROM
  film
INNER JOIN
  film_category
  ON film.film_id = film_category.film_id
GROUP BY
  film_category.category_id
ORDER BY
  film_category.category_id;
```

We can use the above in the subquery after an `ANY` operator. This `ANY` operator query returns all the films whose lengths are greater than or equal to the returned list of lengths in the subquery. (So, basically the films whose lengths are greater than or equal to 178 minutes.)

```{sql connection=con_dvd}
SELECT
  title
FROM
  film
WHERE
  length >= ANY(
    SELECT
      MAX(film.length)
    FROM
      film
    INNER JOIN
      film_category
      ON film.film_id = film_category.film_id
    GROUP BY
      film_category.category_id
  );
```

Note that if the subquery doesn't return any rows, then the entire query returns no rows.

### `ANY` vs. `IN`

`= ANY` is equivalent to the `IN` operator.

The following example gets the film whose category is either `Action` or `Drama`.

```{sql connection=con_dvd}
SELECT
  title,
  category_id
FROM
  film
INNER JOIN 
  film_category
  USING(film_id)
WHERE
  category_id = ANY(
    SELECT
      category_id
    FROM
      category
    WHERE
      NAME = 'Action' OR NAME = 'Drama'
    );
```

The following statement uses the IN operator which produces the same result.

```{sql connection=con_dvd}
SELECT
  title,
  category_id
FROM
  film
INNER JOIN 
  film_category
  USING(film_id)
WHERE
  category_id IN(
    SELECT
      category_id
    FROM
      category
    WHERE
      NAME = 'Action' OR NAME = 'Drama'
    );
```

Note that the `<> ANY` operator is different from `NOT IN`. The expression...

`x <> ANY (a,b,c)`

... is equivalent to...

`x <> a OR x <> b OR x <> c`.


```
###@    #==--  :  --==#    @##==---==##@##==---==##@    #==--  :  --==#    @###
#==##@    #==-- --==#    @##==---==##@   @##==---==##@    #==-- --==#    @##==#
#--==##@    #==-==#    @##==---==##@   #   @##==---==##@    #==-==#    @##==--#
#=---==##@    #=#    @##==---==##@    #=#    @##==---==##@    #=#    @##==---=#
##==---==##@   #   @##==---==##@    #==-==#    @##==---==##@   #   @##==---==##
#@##==---==##@   @##==---==##@    #==-- --==#    @##==---==##@   @##==---==##@#
#  @##==---==##@##==---==##@    EXTRA  :  SPACE    @##==---==##@##==---==##@  #
#@##==---==##@   @##==---==##@    #==-- --==#    @##==---==##@   @##==---==##@#
##==---==##@   #   @##==---==##@    #==-==#    @##==---==##@   #   @##==---==##
#=---==##@    #=#    @##==---==##@    #=#    @##==---==##@    #=#    @##==---=#
#--==##@    #==-==#    @##==---==##@   #   @##==---==##@    #==-==#    @##==--#
#==##@    #==-- --==#    @##==---==##@   @##==---==##@    #==-- --==#    @##==#
###@    #==--  :  --==#    @##==---==##@##==---==##@    #==--  :  --==#    @###
#==##@    #==-- --==#    @##==---==##@   @##==---==##@    #==-- --==#    @##==#
#--==##@    #==-==#    @##==---==##@   #   @##==---==##@    #==-==#    @##==--#
#=---==##@    #=#    @##==---==##@    #=#    @##==---==##@    #=#    @##==---=#
##==---==##@   #   @##==---==##@    #==-==#    @##==---==##@   #   @##==---==##
#@##==---==##@   @##==---==##@    #==-- --==#    @##==---==##@   @##==---==##@#
#  @##==---==##@##==---==##@    EXTRA  :  SPACE    @##==---==##@##==---==##@  #
#@##==---==##@   @##==---==##@    #==-- --==#    @##==---==##@   @##==---==##@#
##==---==##@   #   @##==---==##@    #==-==#    @##==---==##@   #   @##==---==##
#=---==##@    #=#    @##==---==##@    #=#    @##==---==##@    #=#    @##==---=#
#--==##@    #==-==#    @##==---==##@   #   @##==---==##@    #==-==#    @##==--#
#==##@    #==-- --==#    @##==---==##@   @##==---==##@    #==-- --==#    @##==#
###@    #==--  :  --==#    @##==---==##@##==---==##@    #==--  :  --==#    @###
```
